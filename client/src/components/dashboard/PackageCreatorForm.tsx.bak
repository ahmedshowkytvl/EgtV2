import React, { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { useMutation } from "@tanstack/react-query";
import { z } from "zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Loader2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { queryClient } from "@/lib/queryClient";

// Validation schema
const packageFormSchema = z.object({
  name: z.string().min(3, { message: "Package name must be at least 3 characters" }),
  description: z.string().min(10, { message: "Description must be at least 10 characters" }),
  price: z.coerce.number().positive({ message: "Price must be a positive number" }),
  category: z.string({ required_error: "Please select a destination" }),
  categoryId: z.coerce.number({ required_error: "Please select a package category" }),
  startDate: z.date({ required_error: "Start date is required" }),
  endDate: z.date({ required_error: "End date is required" }),
  selectedHotels: z.array(z.string()).optional(),
  adultCount: z.coerce.number().min(1, { message: "At least 1 adult is required" }),
  childrenCount: z.coerce.number().min(0, { message: "Cannot be negative" }),
  infantCount: z.coerce.number().min(0, { message: "Cannot be negative" }),
  rooms: z.array(z.object({
    id: z.string(),
    name: z.string(),
    hotelId: z.string(),
    hotelName: z.string(),
    price: z.coerce.number()
  })).optional(),
  pricingMode: z.enum(["per_booking", "per_percentage", "per_amount"]),
  includedFeatures: z.array(z.string()).optional(),
});

type PackageFormValues = z.infer<typeof packageFormSchema>;

const pricingOptions = [
  { id: "adult", label: "Adult (12+ years)" },
  { id: "child", label: "Child (2-11 years)" },
  { id: "infant", label: "Infant (0-23 months)" },
];

const hotels = [
  { id: "hotel1", name: "Pyramids View Hotel", rooms: ["Deluxe Room", "Superior Room", "Suite"] },
  { id: "hotel2", name: "Nile Palace Resort", rooms: ["Standard Room", "Executive Room", "Royal Suite"] },
  { id: "hotel3", name: "Desert Oasis Lodge", rooms: ["Garden View", "Pool View", "Presidential Suite"] },
];

const features = [
  { id: "breakfast", label: "Breakfast Included" },
  { id: "lunch", label: "Lunch Included" },
  { id: "dinner", label: "Dinner Included" },
  { id: "airport_transfer", label: "Airport Transfer" },
  { id: "city_tour", label: "City Tour" },
  { id: "wifi", label: "Free Wi-Fi" },
  { id: "excursion", label: "Optional Excursions" },
];

// This static array will be replaced by the dynamic data from packageCategories
const categoryOptions = [
  { value: "cultural", label: "Cultural Tours" },
  { value: "beach", label: "Beach Holidays" },
  { value: "adventure", label: "Adventure" },
  { value: "honeymoon", label: "Honeymoon" },
  { value: "family", label: "Family Friendly" },
  { value: "luxury", label: "Luxury" },
];

export interface PackageCreatorFormProps {
  packageId?: string; // Optional package ID for edit mode
}

export function PackageCreatorForm({ packageId }: PackageCreatorFormProps) {
  const isEditMode = !!packageId;
  
  const { toast } = useToast();
  const [pricingRules, setPricingRules] = useState([
    { id: "adult", value: 100, percentage: true },
    { id: "child", value: 75, percentage: true },
    { id: "infant", value: 0, percentage: true },
  ]);
  const [images, setImages] = useState<{ id: string; file: File | null; preview: string; isMain: boolean }[]>([]);
  const [availableRooms, setAvailableRooms] = useState<any[]>([]);
  const [filteredRooms, setFilteredRooms] = useState<any[]>([]);
  const [aiGenerating, setAiGenerating] = useState<boolean>(false);
  const [isInitialized, setIsInitialized] = useState<boolean>(false);
  
  // Track whether we're submitting an update or create
  const [isUpdating, setIsUpdating] = useState<boolean>(false);

  // Fetch destinations for the dropdown
  const { data: destinations = [] } = useQuery<any[]>({
    queryKey: ['/api/destinations'],
  });
  
  // Fetch package categories for the dropdown
  const { data: packageCategories = [] } = useQuery<any[]>({
    queryKey: ['/api/package-categories'],
  });

  // Mock rooms data with capacity info - in a real app, this would come from your API
  const allRooms = [
    { id: "room1", name: "Deluxe Room", hotelId: "hotel1", hotelName: "Pyramids View Hotel", maxAdults: 2, maxChildren: 1, maxInfants: 1, price: 150 },
    { id: "room2", name: "Superior Room", hotelId: "hotel1", hotelName: "Pyramids View Hotel", maxAdults: 3, maxChildren: 2, maxInfants: 1, price: 200 },
    { id: "room3", name: "Suite", hotelId: "hotel1", hotelName: "Pyramids View Hotel", maxAdults: 4, maxChildren: 2, maxInfants: 2, price: 300 },
    { id: "room4", name: "Standard Room", hotelId: "hotel2", hotelName: "Nile Palace Resort", maxAdults: 2, maxChildren: 1, maxInfants: 1, price: 140 },
    { id: "room5", name: "Executive Room", hotelId: "hotel2", hotelName: "Nile Palace Resort", maxAdults: 2, maxChildren: 2, maxInfants: 1, price: 220 },
    { id: "room6", name: "Royal Suite", hotelId: "hotel2", hotelName: "Nile Palace Resort", maxAdults: 4, maxChildren: 3, maxInfants: 2, price: 400 },
    { id: "room7", name: "Garden View", hotelId: "hotel3", hotelName: "Desert Oasis Lodge", maxAdults: 2, maxChildren: 0, maxInfants: 1, price: 120 },
    { id: "room8", name: "Pool View", hotelId: "hotel3", hotelName: "Desert Oasis Lodge", maxAdults: 3, maxChildren: 1, maxInfants: 1, price: 180 },
    { id: "room9", name: "Presidential Suite", hotelId: "hotel3", hotelName: "Desert Oasis Lodge", maxAdults: 6, maxChildren: 4, maxInfants: 2, price: 500 },
  ];

  // Fetch countries for the dropdown
  const { data: countries = [] } = useQuery<any[]>({
    queryKey: ['/api/countries'],
  });
  
  
  // Fetch cities based on selected country
  const [selectedCountryId, setSelectedCountryId] = useState<number | null>(null);
  const { data: cities = [] } = useQuery<any[]>({
    queryKey: ['/api/cities'],  // Get all cities at once, we'll filter in the UI
  });
  
  // Fetch the package data if in edit mode
  const { data: existingPackageData, isLoading: isLoadingPackage } = useQuery<any>({
    queryKey: ['/api/packages'],
    select: (packages) => {
      // Find the package with matching ID from the packages array
      if (packageId && Array.isArray(packages)) {
        console.log('Finding package with ID:', packageId);
        const pkg = packages.find(p => p.id === parseInt(packageId));
        console.log('Found package:', pkg);
        return pkg;
      }
      return undefined;
    },
    enabled: isEditMode,
  });
  
  // Initialize form with empty values (will be updated when editing)
  const form = useForm<PackageFormValues>({
    resolver: zodResolver(packageFormSchema),
    defaultValues: {
      name: "",
      overview: "",
      basePrice: 0,
      countryId: undefined,
      cityId: undefined,
      category: undefined,
      categoryId: undefined,
      pricingMode: "per_booking",
      includedFeatures: [],
      selectedHotels: [],
      adultCount: 2,
      childrenCount: 0,
      infantCount: 0,
      rooms: [],
    },
  });

  // Package mutation (handles both create and update)
  const packageMutation = useMutation({
    mutationFn: async (formData: PackageFormValues) => {
      // Get the main image URL (or a default if none is set)
      const mainImage = images.find(img => img.isMain);
      // If the preview URL is a blob URL, use a placeholder or existing image
      let mainImageUrl = mainImage ? mainImage.preview : "https://images.unsplash.com/photo-1540541338287-41700207dee6?q=80&w=800";
      if (mainImageUrl && mainImageUrl.startsWith('blob:')) {
        // For edit mode, if we have existing data, use the existing image URL
        if (isEditMode && existingPackageData && existingPackageData.imageUrl) {
          mainImageUrl = existingPackageData.imageUrl;
        } else {
          // Otherwise use placeholder
          mainImageUrl = "https://images.unsplash.com/photo-1540541338287-41700207dee6?q=80&w=800";
        }
      }
      
      // Handle gallery URLs
      let galleryUrls: string[] = [];
      
      if (isEditMode && existingPackageData && existingPackageData.galleryUrls) {
        // For edit mode, if we already have gallery URLs in the database, start with those
        try {
          // Parse the existing gallery URLs
          const existingGalleryUrls: string[] = typeof existingPackageData.galleryUrls === 'string' 
            ? JSON.parse(existingPackageData.galleryUrls) 
            : (existingPackageData.galleryUrls as string[] || []);
            
          // Then add all non-blob URLs from the images array
          const validNewUrls = images
            .map(img => img.preview)
            .filter(url => !url.startsWith('blob:'));
            
          // Merge the two lists, filtering out duplicates
          // Use Array.from to properly handle the Set to Array conversion for TypeScript
          galleryUrls = Array.from(new Set([...existingGalleryUrls, ...validNewUrls]));
        } catch (e) {
          console.error("Error parsing galleryUrls:", e);
          galleryUrls = [];
        }
      } else {
        // For new packages, just use valid URLs
        galleryUrls = images
          .map(img => img.preview)
          .filter(url => !url.startsWith('blob:'));
      }
      
      // Transform the form data to match the API schema
      // Log current form values for debugging
      console.log('Form submission values:', {
        name: formData.name,
        overview: formData.overview,
        basePrice: formData.basePrice,
        countryId: formData.countryId,
        cityId: formData.cityId,
        category: formData.category,
        categoryId: formData.categoryId,
      });
      
      // Ensure countryId and cityId are valid numbers
      const countryId = formData.countryId ? Number(formData.countryId) : null;
      const cityId = formData.cityId ? Number(formData.cityId) : null;
      
      console.log('Parsed countryId:', countryId, 'cityId:', cityId);
        
      const packagePayload = {
        title: formData.name,
        description: formData.overview,
        price: formData.basePrice,
        discountedPrice: Math.round(formData.basePrice * 0.9), // 10% discount as example
        imageUrl: mainImageUrl,
        galleryUrls: galleryUrls,
        duration: Math.ceil((formData.endDate.getTime() - formData.startDate.getTime()) / (1000 * 3600 * 24)), // Calculate days
        rating: 45, // Default 4.5 stars (stored as 45 in DB)
        destinationId: parseInt(formData.category), // Using the selected destination ID
        categoryId: formData.categoryId, // New field for package category
        featured: true,
        type: categoryOptions.find(c => c.value === formData.category)?.label || "Tour Package",
        inclusions: formData.includedFeatures || ["Accommodation", "Breakfast", "Tour Guide"],
        countryId: countryId,
        cityId: cityId,
        startDate: formData.startDate.toISOString(),
        endDate: formData.endDate.toISOString(),
        adultCount: formData.adultCount,
        childrenCount: formData.childrenCount,
        infantCount: formData.infantCount
      };
      
      // Log final payload for debugging
      console.log('Package payload:', packagePayload);
      
      // Determine if this is an update or create
      const isUpdate = isEditMode && packageId;
      const url = isUpdate 
        ? `/api/admin/packages/${packageId}` 
        : '/api/admin/packages';
      
      const method = isUpdate ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method: method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(packagePayload),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to ${isUpdate ? 'update' : 'create'} package`);
      }
      
      return await response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/packages'] });
      
      // Show success message
      const action = isEditMode ? "Updated" : "Created";
      toast({
        title: `Package ${action}`,
        description: `The package was ${action.toLowerCase()} successfully`,
        variant: "default",
      });
      
      if (!isEditMode) {
        // Reset form after successful creation (not after update)
        form.reset();
        
        // Reset any component state
        setImages([]);
        setPricingRules([
          { id: "adult", value: 100, percentage: true },
          { id: "child", value: 75, percentage: true },
          { id: "infant", value: 0, percentage: true },
        ]);
      }
    },
    onError: (error: Error) => {
      toast({
        title: `Error ${isEditMode ? 'updating' : 'creating'} package`,
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: PackageFormValues) => {
    console.log("Form submitted", data);
    
    // Use our validation utilities for better error handling
    
    // 1. Required fields validation
    const requiredFieldsValid = validateRequiredFields(
      data,
      ['name', 'overview', 'countryId', 'cityId', 'category', 'startDate', 'endDate', 'basePrice'],
      {
        name: 'Package Name',
        overview: 'Overview',
        countryId: 'Country',
        cityId: 'City',
        category: 'Destination',
        startDate: 'Start Date',
        endDate: 'End Date',
        basePrice: 'Base Price'
      }
    );
    
    if (!requiredFieldsValid) return;
    
    // 2. Numeric fields validation
    const numericFieldsValid = validateNumericFields(
      data,
      [
        { field: 'basePrice', label: 'Base Price', min: 0.01 },
        { field: 'adultCount', label: 'Adult Count', min: 1, integer: true },
        { field: 'childrenCount', label: 'Children Count', min: 0, integer: true },
        { field: 'infantCount', label: 'Infant Count', min: 0, integer: true }
      ]
    );
    
    if (!numericFieldsValid) return;
    
    // 3. Date fields validation
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const dateFieldsValid = validateDateFields(
      data,
      [
        { 
          field: 'startDate', 
          label: 'Start Date', 
          notInPast: true 
        },
        { 
          field: 'endDate', 
          label: 'End Date', 
          notInPast: true 
        }
      ],
      [
        {
          startField: 'startDate',
          endField: 'endDate',
          startLabel: 'Start Date',
          endLabel: 'End Date'
        }
      ]
    );
    
    if (!dateFieldsValid) return;
    
    // 4. Custom validations
    const customValidationsValid = validateForm(data, [
      {
        condition: data.endDate.getTime() === data.startDate.getTime(),
        errorMessage: {
          title: "Invalid Duration",
          description: "The package must have at least 1 day duration"
        },
        variant: "destructive"
      },
      {
        condition: data.includedFeatures === undefined || (data.includedFeatures && data.includedFeatures.length === 0),
        errorMessage: {
          title: "No Features Selected",
          description: "Please select at least one included feature for the package"
        },
        variant: "destructive"
      }
    ]);
    
    if (!customValidationsValid) return;
    
    // All validations passed, proceed with submission
    packageMutation.mutate(data);
  };

  // Effect to load package data when in edit mode
  useEffect(() => {
    if (isEditMode && existingPackageData && !isInitialized) {
      console.log('Initializing edit form with package data:', existingPackageData);
      
      // Parse JSON strings into arrays if needed
      const inclusions = typeof existingPackageData.inclusions === 'string' 
        ? JSON.parse(existingPackageData.inclusions) 
        : existingPackageData.inclusions || [];
      
      // Handle gallery URLs, ensuring we have a non-null array even if no images
      let galleryUrls: string[] = [];
      if (existingPackageData.galleryUrls) {
        galleryUrls = typeof existingPackageData.galleryUrls === 'string' 
          ? JSON.parse(existingPackageData.galleryUrls) 
          : (existingPackageData.galleryUrls as string[] || []);
      }
      
      // If galleryUrls is still null or undefined, use an empty array
      if (!galleryUrls) galleryUrls = [];
      
      // If we don't have any gallery images but we have a main image, add it to the gallery
      if (galleryUrls.length === 0 && existingPackageData.imageUrl) {
        galleryUrls = [existingPackageData.imageUrl];
      }
      
      // Find the destination data for this package to get country and city
      const destinationId = existingPackageData.destinationId;
      const destination = destinations.find(d => d.id === destinationId);
      console.log('Found destination for package:', destination);
      
      // Determine country ID from the destination
      let countryId = existingPackageData.countryId;
      if (!countryId && destination) {
        // Try to find the country from the country name
        const country = countries.find(c => c.name === destination.country);
        if (country) {
          countryId = country.id;
          console.log('Auto-detected country ID:', countryId);
        }
      }
      
      // Set the country ID first to load cities
      if (countryId) {
        setSelectedCountryId(countryId);
      }
      
      // Ensure we have the main image loaded
      const mainImageUrl = existingPackageData.imageUrl || "https://images.unsplash.com/photo-1540541338287-41700207dee6?q=80&w=800";
      
      // Create a default gallery with the main image if no gallery exists
      if (galleryUrls.length === 0 && mainImageUrl) {
        galleryUrls = [mainImageUrl];
      }
      
      // Make sure the main image is included in the gallery
      if (mainImageUrl && !galleryUrls.includes(mainImageUrl)) {
        galleryUrls.unshift(mainImageUrl);
      }
      
      // Log image information for debugging
      console.log('Package main image URL:', mainImageUrl);
      console.log('Gallery URLs:', galleryUrls);
      
      // Create image objects from galleryUrls
      const imageObjects = galleryUrls.map((url: string, index: number) => ({
        id: `existing-${index}`,
        file: null, 
        preview: url,
        isMain: url === mainImageUrl // Set main image flag
      }));
      
      // Ensure at least one image is marked as main
      if (imageObjects.length > 0 && !imageObjects.some((img: {isMain: boolean}) => img.isMain)) {
        console.log('No main image found, setting first image as main');
        imageObjects[0].isMain = true;
      }
      
      // Log the created image objects
      console.log('Created image objects:', imageObjects);
      
      // Set state values
      setImages(imageObjects);
      setIsInitialized(true);
      
      // Calculate dates based on duration if not provided
      const today = new Date();
      const startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 7); // Default to 1 week from now
      const endDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 7 + (existingPackageData.duration || 7)); // Default to 1 week duration
      
      // Try to detect city ID based on the destination name matching a city name
      let cityId = existingPackageData.cityId;
      if (!cityId && destination) {
        if (destination.city_id) {
          cityId = destination.city_id;
        } else {
          // Try to find a city with the same name as the destination
          const matchedCity = cities.find(city => 
            city.name === destination.name && 
            (!countryId || city.countryId === countryId)
          );
          
          if (matchedCity) {
            cityId = matchedCity.id;
            console.log('Matched city by name:', matchedCity.name, 'ID:', cityId);
          } else {
            // Hard-coded mappings based on known destination-to-city relationships
            const destinationCityMap: Record<number, number> = {
              1: 1,  // Cairo destination → Cairo city
              2: 4,  // Dubai destination → Dubai city
              3: 3,  // Sharm El Sheikh destination → Sharm El Sheikh city
              4: 7,  // Petra destination → Petra city
              5: 8,  // Marrakech destination → Marrakech city
            };
            
            if (destinationCityMap[destination.id]) {
              cityId = destinationCityMap[destination.id];
              console.log('Applied city mapping for destination ID:', destination.id, 'City ID:', cityId);
            }
          }
        }
      }
      
      // Log what we found for debugging
      console.log('Setting form values with:', {
        countryId,
        cityId,
        destinationId: existingPackageData.destinationId,
        category: existingPackageData.destinationId?.toString()
      });
      
      // Wait for the country to load cities before setting the form values
      setTimeout(() => {
        // Log the available cities for the selected country
        console.log('Available cities for country ID', countryId, ':', cities);
        
        // Set form values
        form.reset({
          name: existingPackageData.title || "",
          overview: existingPackageData.description || "",
          basePrice: existingPackageData.price || 0,
          countryId: countryId,
          cityId: cityId,
          category: existingPackageData.destinationId?.toString() || undefined,
          // Set dates with sensible defaults
          startDate: startDate,
          endDate: endDate,
          pricingMode: "per_booking", // Default if not available
          includedFeatures: inclusions,
          adultCount: 2,
          childrenCount: 0,
          infantCount: 0,
        });
        
        // Force update the form control values directly as a backup
        form.setValue('countryId', countryId);
        form.setValue('cityId', cityId);
        
        console.log('Form values set:', form.getValues());
      }, 800); // Give a longer delay to ensure cities are loaded
    }
  }, [existingPackageData, isEditMode, form, isInitialized, destinations, countries, cities]);

  // Effect to initialize rooms when component loads
  useEffect(() => {
    // This would normally be an API call in a real app
    const adultCount = form.getValues("adultCount") || 2;
    const childrenCount = form.getValues("childrenCount") || 0;
    const infantCount = form.getValues("infantCount") || 0;
    
    setAvailableRooms(allRooms);
    filterRoomsByCapacity(allRooms, adultCount, childrenCount, infantCount);
  }, []);

  const handleHotelSelectionChange = (selectedHotelIds: string[]) => {
    form.setValue("selectedHotels", selectedHotelIds);
    updateAvailableRooms(selectedHotelIds);
  };
  
  const updateAvailableRooms = (selectedHotelIds: string[]) => {
    const hotelRooms = allRooms.filter(room => 
      selectedHotelIds.includes(room.hotelId)
    );
    setAvailableRooms(hotelRooms);
    
    const adultCount = form.getValues("adultCount") || 2;
    const childrenCount = form.getValues("childrenCount") || 0;
    const infantCount = form.getValues("infantCount") || 0;
    
    filterRoomsByCapacity(hotelRooms, adultCount, childrenCount, infantCount);
  };
  
  const filterRoomsByCapacity = (rooms: any[], adults: number, children: number, infants: number) => {
    const filtered = rooms.filter(room => 
      room.maxAdults >= adults && 
      room.maxChildren >= children && 
      room.maxInfants >= infants
    );
    setFilteredRooms(filtered);
    
    // Clear selected rooms that no longer match criteria
    const currentSelectedRooms = form.getValues("rooms") || [];
    const validRoomIds = filtered.map(room => room.id);
    const validSelectedRooms = currentSelectedRooms.filter(
      room => validRoomIds.includes(room.id)
    );
    form.setValue("rooms", validSelectedRooms);
  };

  const handlePricingRuleChange = (id: string, field: "value" | "percentage", value: number | boolean) => {
    setPricingRules(prev => 
      prev.map(rule => 
        rule.id === id 
          ? { ...rule, [field]: field === "percentage" ? value : Number(value) } 
          : rule
      )
    );
  };

  // Reference to hidden file input
  const fileInputRef = React.useRef<HTMLInputElement>(null);

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const files = Array.from(e.target.files);

      for (const file of files) {
        // Create a temporary URL for preview until upload completes
        const tempPreview = URL.createObjectURL(file);

        // Read the file as base64
        const reader = new FileReader();
        reader.readAsDataURL(file);

        reader.onload = async () => {
          try {
            // Upload the image to the server
            const response = await fetch('/api/upload-image', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                image: reader.result,
                type: file.name.split('.').pop() || 'jpeg'
              }),
            });

            if (!response.ok) {
              throw new Error('Failed to upload image');
            }

            const data = await response.json();
            const serverUrl = data.imageUrl; // URL to the uploaded image on the server

            // Set as main image if this is the first image
            const isFirstImage = images.length === 0;

            // Add to images array with the permanent server URL
            const newImage = {
              id: Math.random().toString(36).substring(7),
              file: null, // We don't need to keep the file object anymore
              preview: serverUrl, // Use the server URL instead of blob URL
              isMain: isFirstImage
            };

            setImages(prev => [...prev, newImage]);

            // Clean up the temporary blob URL
            URL.revokeObjectURL(tempPreview);
          } catch (error) {
            console.error('Error uploading image:', error);
            toast({
              title: "Error uploading image",
              description: "Failed to upload image to server",
              variant: "destructive",
            });
          }
        };
      }

      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  
  const setMainImage = (id: string) => {
    setImages(prev => 
      prev.map(image => ({
        ...image,
        isMain: image.id === id
      }))
    );
  };
  
  const addImage = () => {
    // Trigger the hidden file input
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  const removeImage = (id: string) => {
    // Find the image to remove
    const imageToRemove = images.find(img => img.id === id);
    const wasMainImage = imageToRemove?.isMain || false;
    
    // Revoke object URL to prevent memory leaks
    if (imageToRemove && imageToRemove.preview && !imageToRemove.preview.startsWith('https://placehold.co')) {
      URL.revokeObjectURL(imageToRemove.preview);
    }
    
    // Remove from state
    const updatedImages = images.filter(image => image.id !== id);
    
    // If we removed the main image and there are other images, set the first one as main
    if (wasMainImage && updatedImages.length > 0) {
      updatedImages[0].isMain = true;
    }
    
    setImages(updatedImages);
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <div className="mb-6">
          <FormRequiredFieldsNote />
          {packageMutation.isError && (
            <FormValidationAlert 
              status="error" 
              title={isEditMode ? "Package Update Failed" : "Package Creation Failed"} 
              message={packageMutation.error?.message || `An error occurred while ${isEditMode ? 'updating' : 'creating'} the package.`} 
              className="mt-3"
            />
          )}
        </div>
        <Tabs defaultValue="basic" className="w-full">
          <TabsList className="grid w-full grid-cols-4">
            <TabsTrigger value="basic">Basic Info</TabsTrigger>
            <TabsTrigger value="pricing">Pricing Rules</TabsTrigger>
            <TabsTrigger value="accommodation">Hotel & Rooms</TabsTrigger>
            <TabsTrigger value="features">Features</TabsTrigger>
          </TabsList>
          
          {/* Basic Info Tab */}
          <TabsContent value="basic" className="space-y-6 pt-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Package Name</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter package name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              {/* Country Selection */}
              <FormField
                control={form.control}
                name="countryId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Country</FormLabel>
                    <Select 
                      onValueChange={(value) => {
                        const countryId = parseInt(value);
                        console.log('Country selection changed to:', countryId);
                        field.onChange(countryId);
                        setSelectedCountryId(countryId);
                        // Reset cityId when country changes
                        form.setValue("cityId", null as any);
                        
                        // Log available cities for the selected country
                        const filteredCities = Array.isArray(cities) ? 
                          cities.filter(city => city.countryId === countryId) : [];
                        console.log('Available cities for country', countryId, ':', filteredCities);
                      }} 
                      value={field.value?.toString()}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select a country" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {countries.map((country: any) => (
                          <SelectItem key={country.id} value={country.id.toString()}>
                            {country.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              {/* City Selection */}
              <FormField
                control={form.control}
                name="cityId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>City</FormLabel>
                    <Select 
                      onValueChange={(value) => {
                        field.onChange(parseInt(value));
                      }} 
                      value={field.value?.toString()}
                      disabled={!selectedCountryId}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder={selectedCountryId ? "Select a city" : "Select a country first"} />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {Array.isArray(cities) && cities
                          .filter((city: any) => city.countryId === selectedCountryId)
                          .map((city: any) => (
                            <SelectItem key={city.id} value={city.id.toString()}>
                              {city.name}
                            </SelectItem>
                          ))
                        }
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              {/* Destination Selection */}
              <FormField
                control={form.control}
                name="category"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Destination</FormLabel>
                    <Select onValueChange={field.onChange} value={field.value}>
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select a destination" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {destinations.map((destination: any) => (
                          <SelectItem key={destination.id} value={destination.id.toString()}>
                            {destination.name}, {destination.country}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormDescription>
                      Select the destination for this package
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="categoryId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Package Category <span className="text-destructive">*</span></FormLabel>
                    <Select 
                      onValueChange={(value) => field.onChange(parseInt(value))}
                      defaultValue={field.value?.toString()}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select a package category" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {packageCategories.map((category) => (
                          <SelectItem key={category.id} value={category.id.toString()}>
                            {category.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormDescription>
                      Choose the category that best describes this package.
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            
            <FormField
              control={form.control}
              name="overview"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Overview</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter package overview" 
                      className="min-h-[120px]" 
                      {...field} 
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="basePrice"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Base Price</FormLabel>
                  <FormControl>
                    <div className="relative">
                      <span className="absolute left-3 top-2.5 text-zinc-500">$</span>
                      <Input className="pl-7" type="number" {...field} />
                    </div>
                  </FormControl>
                  <FormDescription>
                    The base price for this package
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <FormField
                control={form.control}
                name="startDate"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>Start Date</FormLabel>
                    <Popover>
                      <PopoverTrigger asChild>
                        <FormControl>
                          <Button
                            variant={"outline"}
                            className={cn(
                              "w-full pl-3 text-left font-normal",
                              !field.value && "text-muted-foreground"
                            )}
                          >
                            {field.value ? (
                              format(field.value, "PPP")
                            ) : (
                              <span>Pick a date</span>
                            )}
                            <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                          </Button>
                        </FormControl>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={field.value}
                          onSelect={field.onChange}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="endDate"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>End Date</FormLabel>
                    <Popover>
                      <PopoverTrigger asChild>
                        <FormControl>
                          <Button
                            variant={"outline"}
                            className={cn(
                              "w-full pl-3 text-left font-normal",
                              !field.value && "text-muted-foreground"
                            )}
                          >
                            {field.value ? (
                              format(field.value, "PPP")
                            ) : (
                              <span>Pick a date</span>
                            )}
                            <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                          </Button>
                        </FormControl>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={field.value}
                          onSelect={field.onChange}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>
            
            <div>
              <h3 className="text-sm font-medium mb-3">Gallery Images</h3>
              
              {/* Hidden file input */}
              <input 
                type="file" 
                ref={fileInputRef}
                className="hidden" 
                accept="image/*"
                onChange={handleImageUpload}
              />
              
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                {images.map(image => (
                  <div key={image.id} className={`relative ${image.isMain ? 'ring-2 ring-primary' : ''}`}>
                    <img 
                      src={image.preview} 
                      alt="Gallery preview" 
                      className="w-full h-32 object-cover rounded-md border" 
                    />
                    <div className="absolute top-2 right-2 flex gap-1">
                      {!image.isMain && (
                        <Button
                          variant="secondary"
                          size="icon"
                          className="h-6 w-6 rounded-full bg-white"
                          onClick={() => setMainImage(image.id)}
                          title="Set as main image"
                        >
                          <Star size={14} className="text-amber-500" />
                        </Button>
                      )}
                      <Button
                        variant="destructive"
                        size="icon"
                        className="h-6 w-6 rounded-full"
                        onClick={() => removeImage(image.id)}
                      >
                        <Trash size={14} />
                      </Button>
                    </div>
                    {image.isMain && (
                      <div className="absolute bottom-2 left-2 bg-primary text-white text-xs px-2 py-1 rounded-md">
                        Main Photo
                      </div>
                    )}
                  </div>
                ))}
                <div className="grid grid-cols-2 gap-4">
                  <Button
                    type="button"
                    variant="outline"
                    onClick={addImage}
                    className="h-32 border-dashed flex flex-col items-center justify-center gap-2"
                  >
                    <ImagePlus size={24} />
                    <span className="text-sm">Add Image</span>
                  </Button>
                  
                  <Button
                    type="button"
                    variant="outline"
                    className="h-32 border-dashed flex flex-col items-center justify-center gap-2 bg-primary/5 hover:bg-primary/10"
                    onClick={() => {
                      // Get values from form
                      const overview = form.getValues('overview');
                      const cityName = cities.find(city => city.id === form.getValues('cityId'))?.name || 'Cairo';
                      
                      if (!overview || overview.length < 10) {
                        toast({
                          title: "Missing Information",
                          description: "Please enter a package overview first (minimum 10 characters)",
                          variant: "destructive"
                        });
                        return;
                      }
                      
                      setAiGenerating(true);
                      
                      // Call the API
                      fetch('/api/admin/packages/generate-image', {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ overview, city: cityName }),
                      })
                        .then(response => {
                          if (!response.ok) {
                            throw new Error('Failed to generate image');
                          }
                          return response.json();
                        })
                        .then(data => {
                          if (data.imageUrl) {
                            // Create a new image object
                            const newImage = {
                              id: Math.random().toString(36).substring(7),
                              file: null, // AI generated images don't have a file
                              preview: data.imageUrl,
                              isMain: images.length === 0 // Make it main if it's the first image
                            };
                            
                            setImages(prev => [...prev, newImage]);
                            
                            toast({
                              title: "Image Generated",
                              description: "AI has generated a new image for your package",
                              variant: "default"
                            });
                          }
                        })
                        .catch(error => {
                          console.error('Error generating image:', error);
                          toast({
                            title: "Generation Failed",
                            description: error.message || "Failed to generate image",
                            variant: "destructive"
                          });
                        })
                        .finally(() => {
                          setAiGenerating(false);
                        });
                    }}
                    disabled={aiGenerating}
                  >
                    {aiGenerating ? (
                      <>
                        <Loader2 size={24} className="animate-spin" />
                        <span className="text-sm">Generating...</span>
                      </>
                    ) : (
                      <>
                        <svg 
                          xmlns="http://www.w3.org/2000/svg" 
                          width="24" 
                          height="24" 
                          viewBox="0 0 24 24" 
                          fill="none" 
                          stroke="currentColor" 
                          strokeWidth="2" 
                          strokeLinecap="round" 
                          strokeLinejoin="round"
                          className="text-primary"
                        >
                          <path d="M12 2c1.5 0 3 1.5 3 3 0 1.4-.7 2.7-1.8 3.2.6.2 1.2.5 1.8.8 1 .5 1.3 1.8.8 2.7-.5.9-1.8 1.3-2.7.8-.7-.4-1.3-.6-2.1-.6s-1.4.2-2.1.6c-1 .5-2.2.2-2.7-.8-.5-1-.2-2.2.8-2.7.6-.3 1.2-.6 1.8-.8C7.7 7.7 7 6.4 7 5c0-1.5 1.5-3 3-3Z" />
                          <path d="M19 16.1c-1.1.6-2.5.1-3.1-1.1-.6-1.1-.2-2.5.9-3.1 1.1-.6 2.5-.1 3.1 1.1.7 1.1.2 2.5-.9 3.1Z" />
                          <path d="M9 14c.3 2.1-1.1 4-3 4-1.5 0-3-1.5-3-3 0-1.4.7-2.7 1.8-3.2-.6-.2-1.2-.5-1.8-.8-1-.5-1.3-1.8-.8-2.7.5-.9 1.7-1.3 2.7-.8.7.4 1.3.6 2.1.6" />
                          <path d="M21 12c0 4.4-3.6 8-8 8" />
                          <path d="M14 19c-1.9 1.9-5.1 2-7 0" />
                        </svg>
                        <span className="text-sm">AI Generate Image</span>
                      </>
                    )}
                  </Button>
                </div>
              </div>
            </div>
          </TabsContent>
          
          {/* Pricing Rules Tab */}
          <TabsContent value="pricing" className="space-y-6 pt-4">
            <FormField
              control={form.control}
              name="pricingMode"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Pricing Mode</FormLabel>
                  <div className="flex flex-col space-y-4">
                    <div className="grid grid-cols-3 gap-4">
                      <div className="flex items-center space-x-2">
                        <input
                          type="radio"
                          id="per_booking"
                          value="per_booking"
                          checked={field.value === "per_booking"}
                          onChange={() => field.onChange("per_booking")}
                          className="h-4 w-4 border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                        <label htmlFor="per_booking" className="text-sm font-medium">
                          Per Booking
                        </label>
                      </div>
                      
                      <div className="flex items-center space-x-2">
                        <input
                          type="radio"
                          id="per_percentage"
                          value="per_percentage"
                          checked={field.value === "per_percentage"}
                          onChange={() => field.onChange("per_percentage")}
                          className="h-4 w-4 border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                        <label htmlFor="per_percentage" className="text-sm font-medium">
                          Per Percentage
                        </label>
                      </div>
                      
                      <div className="flex items-center space-x-2">
                        <input
                          type="radio"
                          id="per_amount"
                          value="per_amount"
                          checked={field.value === "per_amount"}
                          onChange={() => field.onChange("per_amount")}
                          className="h-4 w-4 border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                        <label htmlFor="per_amount" className="text-sm font-medium">
                          Per Amount
                        </label>
                      </div>
                    </div>
                  </div>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <Card>
              <CardContent className="pt-6">
                <h3 className="text-sm font-medium mb-4">Pricing Rules</h3>
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Traveler Type</TableHead>
                      <TableHead>Value</TableHead>
                      <TableHead>Unit</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {pricingRules.map((rule) => (
                      <TableRow key={rule.id}>
                        <TableCell>
                          {pricingOptions.find(option => option.id === rule.id)?.label}
                        </TableCell>
                        <TableCell>
                          <Input
                            type="number"
                            value={rule.value}
                            onChange={(e) => handlePricingRuleChange(rule.id, "value", e.target.value ? parseInt(e.target.value) : 0)}
                            className="w-24"
                          />
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center gap-2">
                            <Switch
                              checked={rule.percentage}
                              onCheckedChange={(checked) => handlePricingRuleChange(rule.id, "percentage", checked)}
                            />
                            <span className="text-sm">
                              {rule.percentage ? "%" : "$"}
                            </span>
                          </div>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  className="mt-4"
                  onClick={() => {
                    // In a real app, you would add a new pricing rule here
                  }}
                >
                  <Plus size={16} className="mr-2" />
                  Add Pricing Rule
                </Button>
              </CardContent>
            </Card>
          </TabsContent>
          
          {/* Accommodation Tab */}
          <TabsContent value="accommodation" className="space-y-6 pt-4">
            {/* Hotel Selection */}
            <div className="grid grid-cols-1 gap-6">
              <h3 className="text-lg font-semibold">Select Hotels</h3>
              <div className="grid grid-cols-1 gap-4">
                {hotels.map((hotel) => (
                  <FormItem 
                    key={hotel.id}
                    className="flex items-center space-x-3 space-y-0 rounded-md border p-4"
                  >
                    <FormControl>
                      <Checkbox
                        checked={Array.isArray(form.watch("selectedHotels")) && form.watch("selectedHotels").includes(hotel.id)}
                        onCheckedChange={(checked) => {
                          const currentHotels = form.watch("selectedHotels") || [];
                          let newSelectedHotels;
                          if (checked) {
                            newSelectedHotels = [...currentHotels, hotel.id];
                          } else {
                            newSelectedHotels = currentHotels.filter(id => id !== hotel.id);
                          }
                          handleHotelSelectionChange(newSelectedHotels);
                        }}
                      />
                    </FormControl>
                    <FormLabel className="font-medium cursor-pointer">
                      {hotel.name}
                    </FormLabel>
                  </FormItem>
                ))}
              </div>
            </div>
            
            {/* Guest Breakdown */}
            <div className="space-y-4 border rounded-md p-4">
              <h3 className="text-lg font-semibold">Guest Breakdown</h3>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <FormField
                  control={form.control}
                  name="adultCount"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Adults (12+ years)</FormLabel>
                      <FormControl>
                        <Input 
                          type="number" 
                          min="1" 
                          {...field} 
                          onChange={(e) => {
                            const value = parseInt(e.target.value);
                            field.onChange(value);
                            const selectedHotels = form.getValues("selectedHotels") || [];
                            if (selectedHotels.length > 0) {
                              updateAvailableRooms(selectedHotels);
                            }
                          }}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={form.control}
                  name="childrenCount"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Children (2-11 years)</FormLabel>
                      <FormControl>
                        <Input 
                          type="number" 
                          min="0" 
                          {...field} 
                          onChange={(e) => {
                            const value = parseInt(e.target.value);
                            field.onChange(value);
                            const selectedHotels = form.getValues("selectedHotels") || [];
                            if (selectedHotels.length > 0) {
                              updateAvailableRooms(selectedHotels);
                            }
                          }}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={form.control}
                  name="infantCount"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Infants (0-23 months)</FormLabel>
                      <FormControl>
                        <Input 
                          type="number" 
                          min="0" 
                          {...field} 
                          onChange={(e) => {
                            const value = parseInt(e.target.value);
                            field.onChange(value);
                            const selectedHotels = form.getValues("selectedHotels") || [];
                            if (selectedHotels.length > 0) {
                              updateAvailableRooms(selectedHotels);
                            }
                          }}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
            </div>
            
            {/* Available Rooms */}
            {Array.isArray(form.watch("selectedHotels")) && form.watch("selectedHotels").length > 0 && (
              <FormField
                control={form.control}
                name="rooms"
                render={() => (
                  <FormItem>
                    <div className="mb-4">
                      <h3 className="text-lg font-semibold">Available Rooms</h3>
                      <FormDescription>
                        Only rooms that can accommodate your specified guest count are shown.
                      </FormDescription>
                    </div>
                    
                    {filteredRooms.length === 0 ? (
                      <div className="text-center p-8 border border-dashed rounded-md">
                        <p className="text-muted-foreground">No rooms match the selected criteria. Try adjusting your guest count or selecting different hotels.</p>
                      </div>
                    ) : (
                      <div className="space-y-6">
                        {hotels
                          .filter(hotel => Array.isArray(form.watch("selectedHotels")) && form.watch("selectedHotels").includes(hotel.id))
                          .map(hotel => (
                            <div key={hotel.id} className="border rounded-md p-4">
                              <h4 className="font-medium text-md mb-3">{hotel.name}</h4>
                              <div className="grid grid-cols-1 gap-3">
                                {filteredRooms
                                  .filter(room => room.hotelId === hotel.id)
                                  .map((room) => (
                                    <FormItem
                                      key={room.id}
                                      className="flex flex-col md:flex-row md:items-center space-y-3 md:space-y-0 md:space-x-3 rounded-md border p-4"
                                    >
                                      <div className="flex items-center space-x-3">
                                        <FormControl>
                                          <Checkbox
                                            checked={Array.isArray(form.watch("rooms")) && form.watch("rooms").some(r => r.id === room.id)}
                                            onCheckedChange={(checked) => {
                                              const currentRooms = form.watch("rooms") || [];
                                              if (checked) {
                                                form.setValue("rooms", [...currentRooms, {
                                                  id: room.id,
                                                  name: room.name,
                                                  hotelId: room.hotelId,
                                                  hotelName: room.hotelName,
                                                  price: room.price
                                                }]);
                                              } else {
                                                form.setValue(
                                                  "rooms",
                                                  currentRooms.filter((r) => r.id !== room.id)
                                                );
                                              }
                                            }}
                                          />
                                        </FormControl>
                                        <div>
                                          <FormLabel className="font-medium cursor-pointer block">
                                            {room.name}
                                          </FormLabel>
                                          <div className="text-sm text-muted-foreground">
                                            Capacity: {room.maxAdults} adults, {room.maxChildren} children, {room.maxInfants} infants
                                          </div>
                                        </div>
                                      </div>
                                      
                                      <div className="ml-auto flex items-center space-x-4">
                                        <FormItem className="flex items-center space-x-2 space-y-0">
                                          <FormLabel>Price: </FormLabel>
                                          <Input 
                                            className="w-24"
                                            type="number" 
                                            min="0"
                                            value={room.price}
                                            onChange={(e) => {
                                              // Update price in local rooms data
                                              const newRooms = filteredRooms.map(r => {
                                                if (r.id === room.id) {
                                                  return {...r, price: parseInt(e.target.value)};
                                                }
                                                return r;
                                              });
                                              setFilteredRooms(newRooms);
                                              
                                              // If this room is already selected, update it in form
                                              const currentRooms = form.getValues("rooms") || [];
                                              const roomIndex = currentRooms.findIndex(r => r.id === room.id);
                                              if (roomIndex !== -1) {
                                                const updatedRooms = [...currentRooms];
                                                updatedRooms[roomIndex] = {
                                                  ...updatedRooms[roomIndex],
                                                  price: parseInt(e.target.value)
                                                };
                                                form.setValue("rooms", updatedRooms);
                                              }
                                            }}
                                          />
                                        </FormItem>
                                      </div>
                                    </FormItem>
                                  ))}
                                
                                {filteredRooms.filter(room => room.hotelId === hotel.id).length === 0 && (
                                  <div className="text-center p-4 border border-dashed rounded-md">
                                    <p className="text-muted-foreground">No rooms in this hotel match the selected guest criteria.</p>
                                  </div>
                                )}
                              </div>
                            </div>
                          ))}
                      </div>
                    )}
                    <FormMessage />
                  </FormItem>
                )}
              />
            )}
          </TabsContent>
          
          {/* Features Tab */}
          <TabsContent value="features" className="space-y-6 pt-4">
            <FormField
              control={form.control}
              name="includedFeatures"
              render={() => (
                <FormItem>
                  <div className="mb-4">
                    <FormLabel>Included Features</FormLabel>
                    <FormDescription>
                      Select the features that are included in this package
                    </FormDescription>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {features.map((feature) => (
                      <FormItem
                        key={feature.id}
                        className="flex items-center space-x-3 space-y-0 rounded-md border p-4"
                      >
                        <FormControl>
                          <Checkbox
                            checked={Array.isArray(form.watch("includedFeatures")) && form.watch("includedFeatures").includes(feature.id)}
                            onCheckedChange={(checked) => {
                              const currentFeatures = form.watch("includedFeatures") || [];
                              if (checked) {
                                form.setValue("includedFeatures", [...currentFeatures, feature.id]);
                              } else {
                                form.setValue(
                                  "includedFeatures",
                                  currentFeatures.filter((value) => value !== feature.id)
                                );
                              }
                            }}
                          />
                        </FormControl>
                        <FormLabel className="font-normal cursor-pointer">
                          {feature.label}
                        </FormLabel>
                      </FormItem>
                    ))}
                  </div>
                  <FormMessage />
                </FormItem>
              )}
            />
          </TabsContent>
        </Tabs>
        
        <div className="flex flex-col gap-2">
          <div className="flex justify-end space-x-4 pt-4 border-t">
            <Button type="button" variant="outline">Cancel</Button>
            <Button 
              type="submit" 
              className="bg-blue-600 hover:bg-blue-700"
              disabled={packageMutation.isPending}
            >
              {packageMutation.isPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  {isEditMode ? "Updating..." : "Creating..."}
                </>
              ) : isEditMode ? "Update Package" : "Create Package"}
            </Button>
          </div>
          
          {packageMutation.isError && (
            <div className="text-sm text-destructive flex items-center gap-2 mt-2 justify-end">
              <AlertCircle className="h-4 w-4" />
              <span>{packageMutation.error?.message || "An error occurred"}</span>
            </div>
          )}
        </div>
      </form>
    </Form>
  );
}
